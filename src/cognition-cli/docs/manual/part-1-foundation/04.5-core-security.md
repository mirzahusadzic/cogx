# Chapter 4.5: Core Security â€” Protecting the Lattice

> "In God we trust. All others must bring data."
>
> â€” W. Edwards Deming

**Part**: I â€” Foundation<br/>
**Focus**: System Integrity<br/>
**Threat Model**: Mission Poisoning<br/>
**Defense**: Multi-Layer Validation<br/>

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Threat Model â€” Mission Poisoning Attacks](#2-threat-model--mission-poisoning-attacks)
3. [Defense Philosophy](#3-defense-philosophy)
4. [Architecture Overview](#4-architecture-overview)
5. [MissionValidator â€” Pre-Ingestion Gate](#5-missionvalidator--pre-ingestion-gate)
6. [MissionIntegrityMonitor â€” Immutable Audit Trail](#6-missionintegritymonitor--immutable-audit-trail)
7. [SemanticDriftDetector â€” Poisoning Detection](#7-semanticdriftdetector--poisoning-detection)
8. [SecurityConfig â€” User Control](#8-securityconfig--user-control)
9. [Integration with Genesis Command](#9-integration-with-genesis-command)
10. [Core Security vs Oâ‚‚ Security Overlay](#10-core-security-vs-o-security-overlay)

---

## 1. Executive Summary

The core security layer protects **the PGC itself** from attacks that could compromise the cognitive architecture's integrity. This is distinct from the Oâ‚‚ Security overlay, which stores application-level security knowledge.

### Key Distinction

- **Core Security**: Protects THE LATTICE (the cognitive system)
- **Oâ‚‚ Security Overlay**: Stores knowledge ABOUT application security

### Analogy

- **Core Security** = OS kernel security (protects the operating system)
- **Oâ‚‚ Security Overlay** = Security best practices docs (guides developers)

### Why Core Security Matters

**The Mission Documents Define What The System Is FOR.**

If an attacker can gradually poison mission documentsâ€”shifting from "security first" to "balanced approach" to "pragmatic flexibility"â€”they compromise the entire cognitive architecture without ever touching application code.

**Core Security prevents this attack vector.**

---

## 2. Threat Model â€” Mission Poisoning Attacks

### Attack Vector 1: Gradual Mission Poisoning

**Technique**: Attacker submits series of plausible PRs over time

**Progression**:

1. PR 1: "security first" â†’ "security is a priority"
2. PR 2: "security is a priority" â†’ "balanced security approach"
3. PR 3: "balanced security approach" â†’ "pragmatic flexibility"

**Result**: Mission has drifted significantly, but each individual change seemed reasonable.

**Example**:

```diff
# VISION.md (Version 1)
- Security first. Never compromise on validation.

# VISION.md (Version 5 - after gradual poisoning)
+ Balanced approach. Trust experienced developers.
```

### Attack Vector 2: Trust Erosion

**Technique**: Injecting language that undermines security principles

**Patterns**:

- Adding: "trust experienced users", "trust the team"
- Removing: "verify", "validate", "audit"
- Shifting: Deprioritizing validation concepts

**Example**:

```diff
# CODING_PRINCIPLES.md
- Always validate user input. Never trust external data.
+ Experienced developers can skip validation for trusted sources.
```

### Attack Vector 3: Security Weakening

**Technique**: Removing security-focused concepts or adding "pragmatic" language

**Patterns**:

- Removing: "security first", "security-critical", "never bypass"
- Adding: "pragmatic", "flexible", "balanced approach"
- Shifting: Moving security concepts lower in document

**Example**:

```diff
# VISION.md
- 1. Security first
- 2. Privacy by default
- 3. Transparency
+ 1. Move fast and build things
+ 2. Pragmatic security
+ 3. Trust the process
```

### Attack Vector 4: Ambiguity Injection

**Technique**: Adding vague terms to enable malicious interpretations

**Patterns**:

- Adding: "context-dependent", "case-by-case", "use judgment"
- Removing: "always", "never", "must"
- Shifting: Making concrete principles more vague

**Example**:

```diff
# CODING_PRINCIPLES.md
- Never bypass authentication checks.
+ Authentication checks should be applied in most cases.
```

### Attack Vector 5: Velocity Prioritization

**Technique**: Emphasizing speed over safety

**Patterns**:

- Adding: "move fast", "iterate quickly", "ship rapidly"
- Removing: "careful", "thorough", "validated"
- Shifting: Prioritizing speed over safety

**Example**:

```diff
# OPERATIONAL_GUIDANCE.md
- Thorough testing before deployment.
+ Move fast and iterate. Ship early, fix later.
```

---

## 3. Defense Philosophy

### ğŸ”“ Advisory by Default (Warn, Don't Block)

**Principle**: System provides warnings and evidence; humans make final decisions.

**Why**: Prevents false positives from breaking legitimate workflows.

**Implementation**:

- Default mode: `advisory`
- Warnings logged, but ingestion proceeds
- Blocking only in `strict` mode (opt-in)

**Trade-off**: Lower false positive disruption, but requires human vigilance.

### ğŸ” Transparent (All Detection Logic Documented)

**Principle**: Every pattern detection rule is documented and auditable.

**Why**: Users can inspect, challenge, and improve detection logic.

**Implementation**:

- Pattern detection rules in source code
- Thresholds configurable
- No black-box heuristics

**Example**:

```typescript
// Detection rule: Security weakening
const SECURITY_WEAKENING_PATTERNS = [
  /pragmatic\s+security/i,
  /flexible\s+security/i,
  /balanced\s+approach/i,
  /trust\s+experienced/i,
];
```

### ğŸ‘¤ User Control (Easy to Configure/Disable)

**Principle**: Security features can be disabled or tuned per project.

**Why**: Respects developer autonomy while providing protection.

**Implementation**:

- Configuration file: `.cognition/security.json`
- Mode selection: `advisory`, `strict`, `disabled`
- Threshold tuning: `warnThreshold`, `alertThreshold`, `blockThreshold`

### ğŸš« No Telemetry (All Analysis Local)

**Principle**: No data sent to external services.

**Why**: Privacy and security of mission documents.

**Implementation**:

- All validation runs locally
- LLM validation is optional (can use pattern matching only)
- No network calls unless user enables LLM validation

### ğŸ¤ Augment Humans (Help Reviewers, Don't Replace)

**Principle**: System provides evidence for human review.

**Why**: Humans are ultimate authority on mission integrity.

**Implementation**:

- Recommendations are suggestive, not authoritative
- Focus on helping reviewers spot subtle attacks
- Clear evidence for decision-making

---

## 4. Architecture Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   MissionValidator                       â”‚
â”‚  Pre-ingestion gate for mission documents                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                   â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Layer 1:     â”‚    â”‚ Layer 3:     â”‚
â”‚ Content      â”‚    â”‚ Semantic     â”‚
â”‚ Safety       â”‚    â”‚ Drift        â”‚
â”‚ (LLM-based)  â”‚    â”‚ (Embedding)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                   â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Layer 2:     â”‚    â”‚ Layer 4:     â”‚
â”‚ Content      â”‚    â”‚ Structural   â”‚
â”‚ Patterns     â”‚    â”‚ Integrity    â”‚
â”‚ (Regex)      â”‚    â”‚ (Markdown)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                   â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚   MissionIntegrityMonitor â”‚
     â”‚   Immutable audit trail   â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚ .open_cognition â”‚
          â”‚ /mission_       â”‚
          â”‚  integrity/     â”‚
          â”‚  versions.json  â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Components

1. **MissionValidator**: Multi-layer validation before ingestion
2. **MissionIntegrityMonitor**: Immutable audit trail of mission versions
3. **SemanticDriftDetector**: Detects semantic drift and suspicious patterns
4. **SecurityConfig**: User-configurable security settings

### Data Flow

```
Mission Document (VISION.md)
    â”‚
    â–¼
MissionValidator
    â”œâ”€â†’ Layer 1: Content Safety (LLM-based, optional)
    â”œâ”€â†’ Layer 2: Content Patterns (Regex-based, always)
    â”œâ”€â†’ Layer 3: Semantic Drift (Embedding-based)
    â””â”€â†’ Layer 4: Structural Integrity (Markdown)
    â”‚
    â–¼
ValidationResult { safe, layers, recommendation }
    â”‚
    â”œâ”€â†’ [if safe OR advisory mode] â†’ Ingest
    â””â”€â†’ [if unsafe AND strict mode] â†’ Block
    â”‚
    â–¼
MissionIntegrityMonitor.recordVersion()
    â”‚
    â–¼
.open_cognition/mission_integrity/versions.json
```

---

## 5. MissionValidator â€” Pre-Ingestion Gate

**Purpose**: Multi-layer validation before ingesting mission documents

**Location**: `src/core/security/mission-validator.ts`

### Validation Layers

#### Layer 1: Content Safety (LLM-Based, Optional)

**Purpose**: Use eGemma personas to analyze content for malicious patterns

**Enabled**: Only if `config.contentFiltering.llmFilter.enabled === true`

**Persona Mapping**:

| Document Type  | eGemma Persona            |
| -------------- | ------------------------- |
| `strategic`    | `security_validator`      |
| `operational`  | `operational_validator`   |
| `security`     | `security_meta_validator` |
| `mathematical` | `math_validator`          |

**Detection**:

- Malicious patterns (trust erosion, security weakening)
- Ambiguity injection
- Velocity prioritization
- Policy violations

**Trade-off**: Higher accuracy but slower (100-500ms network latency).

#### Layer 2: Content Patterns (Regex-Based, Fallback)

**Purpose**: Pattern matching for suspicious language

**Enabled**: Always (even if LLM validation disabled)

**Patterns Detected**:

**Security Weakening**:

```typescript
const SECURITY_WEAKENING = [
  /pragmatic\s+security/i,
  /flexible\s+security/i,
  /balanced\s+approach/i,
  /skip\s+validation/i,
  /bypass\s+security/i,
];
```

**Trust Erosion**:

```typescript
const TRUST_EROSION = [
  /trust\s+experienced/i,
  /trust\s+the\s+team/i,
  /trusted\s+users/i,
  /skip\s+for\s+trusted/i,
];
```

**Ambiguity Injection**:

```typescript
const AMBIGUITY_INJECTION = [
  /context[\s-]dependent/i,
  /case[\s-]by[\s-]case/i,
  /use\s+judgment/i,
  /in\s+most\s+cases/i,
];
```

**Velocity Prioritization**:

```typescript
const VELOCITY_PRIORITIZATION = [
  /move\s+fast/i,
  /ship\s+quickly/i,
  /iterate\s+rapidly/i,
  /speed\s+over\s+safety/i,
];
```

**Trade-off**: Fast and lightweight, but less nuanced than LLM.

#### Layer 3: Semantic Drift Analysis (Embedding-Based)

**Purpose**: Compare new version against previous versions using embeddings

**Algorithm**:

1. Compute embedding centroid for old version
2. Compute embedding centroid for new version
3. Calculate cosine distance between centroids
4. Identify added/removed/shifted concepts
5. Classify severity based on distance and patterns

**Severity Thresholds**:

| Severity | Distance  | Description          | Action               |
| -------- | --------- | -------------------- | -------------------- |
| None     | < 0.05    | Minor refinements    | Auto-approve         |
| Low      | 0.05-0.15 | Acceptable reframing | Log + approve        |
| Medium   | 0.15-0.30 | Significant changes  | Review recommended   |
| High     | 0.30-0.50 | Major mission shift  | Alert + review       |
| Critical | > 0.50    | Potential poisoning  | Block in strict mode |

**Trade-off**: Requires previous version (cold start problem for first version).

#### Layer 4: Structural Integrity (Markdown Validation)

**Purpose**: Ensure document parses correctly

**Checks**:

- Valid markdown syntax
- No malformed content
- Proper structure

**Trade-off**: Minimal overhead, catches basic corruption.

### Validation Result

```typescript
interface ValidationResult {
  safe: boolean; // All layers passed?
  layers: ValidationLayer[]; // Per-layer results
  recommendation: 'approve' | 'review' | 'reject';
  alertLevel: 'none' | 'info' | 'warning' | 'critical';
  embeddedConcepts?: MissionConcept[];
}

interface ValidationLayer {
  name: string; // e.g., "Content Safety"
  passed: boolean; // Did this layer pass?
  message: string; // Explanation
  evidence?: string[]; // Specific findings
}
```

### Usage Example

```typescript
import { MissionValidator, loadSecurityConfig } from './core/security/index.js';

// Load security config from project root
const config = await loadSecurityConfig(projectRoot);

// Create validator
const validator = new MissionValidator(pgcRoot, config, workbenchUrl);

// Validate mission document
const result = await validator.validate('VISION.md', DocumentType.STRATEGIC);

if (!result.safe) {
  console.warn('âš ï¸  Security concerns detected:');

  for (const layer of result.layers) {
    if (!layer.passed) {
      console.warn(`  - ${layer.name}: ${layer.message}`);
      if (layer.evidence) {
        layer.evidence.forEach((e) => console.warn(`    â€¢ ${e}`));
      }
    }
  }

  // Block in strict mode
  if (result.recommendation === 'reject' && config.mode === 'strict') {
    throw new Error('Mission validation failed in strict mode');
  }

  // Prompt user in advisory mode
  if (result.recommendation === 'reject' && config.mode === 'advisory') {
    const proceed = await promptUser('Continue despite warnings? (y/n)');
    if (!proceed) {
      throw new Error('User cancelled due to validation warnings');
    }
  }
}

console.log('âœ“ Mission validation passed');
```

---

## 6. MissionIntegrityMonitor â€” Immutable Audit Trail

**Purpose**: Creates immutable audit trail of all mission document versions

**Location**: `src/core/security/mission-integrity.ts`

### Mission Version Record

```typescript
interface MissionVersion {
  version: number; // Monotonically increasing
  hash: string; // SHA-256 of content
  timestamp: string; // ISO timestamp
  author?: string; // Git author (if available)
  commitHash?: string; // Git commit SHA
  conceptEmbeddings: number[][]; // Snapshot of embeddings
  semanticFingerprint: string; // Hash of embedding centroid
  conceptTexts: string[]; // Concept texts for comparison
}
```

### Storage Location

**Path**: `.open_cognition/mission_integrity/versions.json`

**Format**:

```json
{
  "versions": [
    {
      "version": 1,
      "hash": "abc123def456...",
      "timestamp": "2025-10-30T12:00:00Z",
      "author": "developer@example.com",
      "commitHash": "a1b2c3d4",
      "conceptEmbeddings": [
        [0.1, 0.2, 0.3, ..., 0.768],
        [0.4, 0.5, 0.6, ..., 0.768]
      ],
      "semanticFingerprint": "def456abc123...",
      "conceptTexts": [
        "Security first",
        "Privacy by default",
        "Transparency in all operations"
      ]
    },
    {
      "version": 2,
      "hash": "xyz789abc012...",
      "timestamp": "2025-10-30T14:30:00Z",
      "author": "developer@example.com",
      "commitHash": "e5f6g7h8",
      "conceptEmbeddings": [...],
      "semanticFingerprint": "ghi789def012...",
      "conceptTexts": [
        "Security first",
        "Privacy by default",
        "Transparency in all operations",
        "User empowerment"
      ]
    }
  ]
}
```

### Invariants

1. **Append-Only**: Versions are never deleted or modified
2. **Monotonic Version Numbers**: Version N+1 always comes after version N
3. **Full Snapshots**: Each version includes complete embedding snapshot
4. **Atomic Writes**: Write to temp file, then rename (prevents corruption)
5. **Git Integration**: Captures git metadata when available

### Security Properties

**Prevents Evidence Erasure**: Attacker cannot delete history of poisoning

**Example**: If attacker submits 5 PRs gradually poisoning mission, versions.json contains complete trail:

```
Version 1: "Security first"           (distance: 0.00 from baseline)
Version 2: "Security is a priority"   (distance: 0.08 from v1)
Version 3: "Balanced security"        (distance: 0.15 from v2)
Version 4: "Pragmatic approach"       (distance: 0.25 from v3)
Version 5: "Trust the team"           (distance: 0.40 from v4)
                                      (distance: 0.88 from v1 âš ï¸)
```

**Forensic Trail**: Enables investigation of mission changes over time

**Rewind Capability**: Can restore previous mission state if compromised

```bash
# Detect poisoning
cognition-cli security audit VISION.md

# Restore to version 1
cognition-cli security restore VISION.md --version 1
```

**Tamper Detection**: Hash chain prevents modification of historical versions

If attacker modifies `versions.json` directly, next `recordVersion()` call detects tampering:

```typescript
// Verify hash chain on each write
const previousVersion = versions[versions.length - 1];
const recomputedHash = this.computeHash(previousVersion);

if (recomputedHash !== previousVersion.hash) {
  throw new Error('Version history has been tampered with');
}
```

### Usage Example

```typescript
import { MissionIntegrityMonitor } from './core/security/index.js';

const monitor = new MissionIntegrityMonitor(pgcRoot);

// Record new version after ingestion
await monitor.recordVersion(visionPath, embeddedConcepts);

// Retrieve version history
const versions = await monitor.getVersions();
console.log(`Mission has ${versions.length} versions`);

// Analyze drift over time
const firstVersion = versions[0];
const latestVersion = versions[versions.length - 1];
const totalDrift = computeCosineDist(
  firstVersion.conceptEmbeddings,
  latestVersion.conceptEmbeddings
);

if (totalDrift > 0.5) {
  console.warn('âš ï¸  Mission has drifted significantly since inception');
}
```

---

## 7. SemanticDriftDetector â€” Poisoning Detection

**Purpose**: Detects semantic drift and suspicious patterns in mission changes

**Location**: `src/core/security/drift-detector.ts`

### Drift Analysis Algorithm

```
1. Load previous version from MissionIntegrityMonitor
2. Compute embedding centroid for old version
3. Compute embedding centroid for new version
4. Calculate cosine distance: dist = 1 - cosine_similarity
5. Identify added/removed/shifted concepts
6. Run pattern detection (security weakening, trust erosion, etc.)
7. Classify severity based on distance and patterns
8. Generate recommendation (approve/review/reject)
```

### Drift Severity Classification

```typescript
function classifySeverity(distance: number, config: DriftThresholds): Severity {
  if (distance < config.low) return 'none';
  if (distance < config.medium) return 'low';
  if (distance < config.high) return 'medium';
  if (distance < config.critical) return 'high';
  return 'critical';
}
```

**Default Thresholds**:

```typescript
const DEFAULT_DRIFT_THRESHOLDS = {
  low: 0.05, // Minor refinements
  medium: 0.15, // Acceptable reframing
  high: 0.3, // Major mission shift
  critical: 0.5, // Potential poisoning
};
```

### Drift Analysis Result

```typescript
interface DriftAnalysis {
  severity: 'none' | 'low' | 'medium' | 'high' | 'critical';
  distance: number; // Cosine distance (0-1)
  addedConcepts: string[]; // New concepts
  removedConcepts: string[]; // Deleted concepts
  shiftedConcepts: {
    concept: string;
    oldPosition: number;
    newPosition: number;
    delta: number; // Positive = deprioritized
  }[];
  suspiciousPatterns: string[]; // Detected attack patterns
  recommendation: 'approve' | 'review' | 'reject';
}
```

### Pattern Detection Rules

#### Security Weakening Detection

**Removed Concepts**:

- "security first"
- "security-critical"
- "never bypass"
- "always validate"

**Added Concepts**:

- "pragmatic"
- "flexible"
- "balanced approach"
- "skip validation"

**Shifted Concepts**:

- Security concepts moved lower in document (deprioritized)

**Example**:

```typescript
// Detect security weakening
const securityConcepts = concepts.filter((c) =>
  /security|validation|verify/i.test(c)
);

const avgOldPosition = mean(securityConcepts.map((c) => c.oldPosition));
const avgNewPosition = mean(securityConcepts.map((c) => c.newPosition));

if (avgNewPosition > avgOldPosition + 5) {
  suspiciousPatterns.push('Security weakening: concepts deprioritized');
}
```

#### Trust Erosion Detection

**Added Concepts**:

- "trust experienced users"
- "trust the team"
- "skip for trusted"

**Removed Concepts**:

- "verify"
- "validate"
- "audit"

**Example**:

```typescript
const trustPatterns = [
  /trust\s+experienced/i,
  /trust\s+the\s+team/i,
  /trusted\s+users/i,
];

const trustConceptsAdded = addedConcepts.filter((c) =>
  trustPatterns.some((p) => p.test(c))
);

if (trustConceptsAdded.length > 0) {
  suspiciousPatterns.push('Trust erosion: added trust-based language');
}
```

#### Ambiguity Injection Detection

**Added Concepts**:

- "context-dependent"
- "case-by-case"
- "use judgment"

**Removed Concepts**:

- "always"
- "never"
- "must"

**Example**:

```typescript
const ambiguityPatterns = [
  /context[\s-]dependent/i,
  /case[\s-]by[\s-]case/i,
  /use\s+judgment/i,
];

const ambiguousConceptsAdded = addedConcepts.filter((c) =>
  ambiguityPatterns.some((p) => p.test(c))
);

if (ambiguousConceptsAdded.length > 0) {
  suspiciousPatterns.push('Ambiguity injection: vague terms added');
}
```

#### Velocity Prioritization Detection

**Added Concepts**:

- "move fast"
- "iterate quickly"
- "ship rapidly"

**Removed Concepts**:

- "careful"
- "thorough"
- "validated"

**Example**:

```typescript
const velocityPatterns = [
  /move\s+fast/i,
  /ship\s+quickly/i,
  /iterate\s+rapidly/i,
];

const velocityConceptsAdded = addedConcepts.filter((c) =>
  velocityPatterns.some((p) => p.test(c))
);

if (velocityConceptsAdded.length > 0) {
  suspiciousPatterns.push('Velocity prioritization: speed over safety');
}
```

### Usage Example

```typescript
import { SemanticDriftDetector } from './core/security/drift-detector.js';

// Create detector with custom thresholds
const detector = new SemanticDriftDetector({
  low: 0.05,
  medium: 0.15,
  high: 0.3,
  critical: 0.5,
});

// Analyze drift between versions
const analysis = await detector.analyzeDrift(oldVersion, newVersion);

// Log findings
console.log(`Semantic distance: ${analysis.distance.toFixed(3)}`);
console.log(`Severity: ${analysis.severity}`);

if (analysis.addedConcepts.length > 0) {
  console.log('Added concepts:', analysis.addedConcepts);
}

if (analysis.removedConcepts.length > 0) {
  console.log('Removed concepts:', analysis.removedConcepts);
}

if (analysis.suspiciousPatterns.length > 0) {
  console.warn('âš ï¸  Suspicious patterns detected:');
  analysis.suspiciousPatterns.forEach((p) => console.warn(`  - ${p}`));
}

console.log(`Recommendation: ${analysis.recommendation}`);
```

---

## 8. SecurityConfig â€” User Control

**Purpose**: User-configurable security settings

**Location**: `src/core/security/security-config.ts`

### Configuration Structure

```typescript
interface SecurityConfig {
  mode: SecurityMode; // 'advisory' | 'strict' | 'disabled'

  contentFiltering: {
    llmFilter: {
      enabled: boolean; // Use LLM-based validation?
      model: string; // eGemma model to use
      confidence: number; // Minimum confidence (0-1)
    };
    patternMatching: {
      enabled: boolean; // Use regex-based validation?
      customPatterns?: string[]; // Additional suspicious patterns
    };
  };

  missionIntegrity: {
    enabled: boolean; // Track mission versions?
    drift: {
      warnThreshold: number; // Warn at this distance
      alertThreshold: number; // Alert at this distance
      blockThreshold: number; // Block at this distance (strict mode)
    };
  };
}
```

### Security Modes

#### Advisory Mode (Default)

**Behavior**:

- All validation layers run
- Warnings are logged
- No blocking (approve with warnings)
- Humans make final decision

**Use Case**: Normal development workflow

**Example Output**:

```
âš ï¸  Security concerns detected:
  - Semantic Drift: High distance (0.35)
  - Content Patterns: Security weakening detected
    â€¢ "pragmatic security" added
    â€¢ "security first" removed
  Recommendation: REVIEW

âœ“ Proceeding with ingestion (advisory mode)
```

#### Strict Mode

**Behavior**:

- All validation layers run
- Critical findings block ingestion
- High/critical drift blocks updates
- Requires explicit override to proceed

**Use Case**: Production environments, high-security projects

**Example Output**:

```
âŒ Mission validation failed:
  - Semantic Drift: Critical distance (0.55)
  - Content Patterns: Security weakening detected
  Recommendation: REJECT

âœ— Ingestion blocked (strict mode)
```

#### Disabled Mode

**Behavior**:

- No validation performed
- All mission changes accepted

**Use Case**: Development/testing only (NOT recommended for production)

### Configuration File

**Location**: `.cognition/security.json` (project root)

**Example Configuration**:

```json
{
  "mode": "advisory",
  "contentFiltering": {
    "llmFilter": {
      "enabled": true,
      "model": "egemma-2b",
      "confidence": 0.7
    },
    "patternMatching": {
      "enabled": true,
      "customPatterns": [
        "skip validation",
        "bypass security",
        "trusted users only"
      ]
    }
  },
  "missionIntegrity": {
    "enabled": true,
    "drift": {
      "warnThreshold": 0.05,
      "alertThreshold": 0.15,
      "blockThreshold": 0.3
    }
  }
}
```

### Loading Configuration

```typescript
import {
  loadSecurityConfig,
  DEFAULT_SECURITY_CONFIG,
} from './core/security/index.js';

// Load from project root (or use defaults if not found)
const config = await loadSecurityConfig(projectRoot);

// Or use defaults explicitly
const config = DEFAULT_SECURITY_CONFIG;

// Or override specific settings
const config = {
  ...DEFAULT_SECURITY_CONFIG,
  mode: 'strict',
  missionIntegrity: {
    enabled: true,
    drift: {
      warnThreshold: 0.03,
      alertThreshold: 0.1,
      blockThreshold: 0.2,
    },
  },
};
```

### Default Configuration

```typescript
export const DEFAULT_SECURITY_CONFIG: SecurityConfig = {
  mode: 'advisory',
  contentFiltering: {
    llmFilter: {
      enabled: false, // Opt-in (requires LLM access)
      model: 'egemma-2b',
      confidence: 0.7,
    },
    patternMatching: {
      enabled: true, // Always on
      customPatterns: [],
    },
  },
  missionIntegrity: {
    enabled: true,
    drift: {
      warnThreshold: 0.05,
      alertThreshold: 0.15,
      blockThreshold: 0.3,
    },
  },
};
```

---

## 9. Integration with Genesis Command

**Purpose**: Integrate mission validation into the genesis command workflow

**Location**: `src/commands/genesis.ts`

### Integration Flow

```typescript
// Load security config
const config = await loadSecurityConfig(projectRoot);

// Skip validation if disabled
if (config.mode === 'disabled') {
  console.log('âš ï¸  Security validation disabled');
  // Proceed directly to ingestion
}

// Create validator
const validator = new MissionValidator(pgcRoot, config, workbenchUrl);

// Validate mission document
const result = await validator.validate(filePath, docType);

// Handle validation result
if (!result.safe) {
  // Log all findings
  console.warn('âš ï¸  Security concerns detected:');
  for (const layer of result.layers) {
    if (!layer.passed) {
      console.warn(`  - ${layer.name}: ${layer.message}`);
      if (layer.evidence) {
        layer.evidence.forEach((e) => console.warn(`    â€¢ ${e}`));
      }
    }
  }

  // Block in strict mode
  if (result.recommendation === 'reject' && config.mode === 'strict') {
    throw new Error('Mission validation failed in strict mode');
  }

  // Prompt user in advisory mode
  if (result.recommendation === 'reject' && config.mode === 'advisory') {
    const proceed = await promptUser('Continue despite warnings? (y/n)');
    if (!proceed) {
      throw new Error('User cancelled due to validation warnings');
    }
  }
}

// Proceed with ingestion
console.log('âœ“ Mission validation passed');

// Ingest mission document
const embeddedConcepts = await ingestMissionDocument(filePath, docType);

// Record version if integrity tracking enabled
if (config.missionIntegrity.enabled) {
  const monitor = new MissionIntegrityMonitor(pgcRoot);
  await monitor.recordVersion(filePath, embeddedConcepts);
  console.log('âœ“ Mission version recorded');
}
```

### Example Output (Advisory Mode)

```bash
$ cognition-cli genesis docs/VISION.md

âš ï¸  Security concerns detected:
  - Semantic Drift: Medium distance (0.18)
    â€¢ Distance from previous version: 0.18
    â€¢ Added concepts: "pragmatic approach", "flexible security"
    â€¢ Removed concepts: "security first"
  - Content Patterns: Security weakening detected
    â€¢ "pragmatic security" pattern found
    â€¢ "trust experienced users" pattern found
  Recommendation: REVIEW

Continue despite warnings? (y/n): y

âœ“ Mission validation completed (advisory mode)
âœ“ Ingesting VISION.md...
âœ“ Embedded 12 concepts
âœ“ Mission version 3 recorded
âœ“ Genesis complete
```

### Example Output (Strict Mode)

```bash
$ cognition-cli genesis docs/VISION.md

âŒ Mission validation failed:
  - Semantic Drift: High distance (0.42)
    â€¢ Distance from previous version: 0.42
    â€¢ Added concepts: "move fast", "trust the team"
    â€¢ Removed concepts: "security first", "never bypass"
  - Content Patterns: Multiple attack patterns detected
    â€¢ Security weakening: "pragmatic security"
    â€¢ Trust erosion: "trust the team"
    â€¢ Velocity prioritization: "move fast"
  Recommendation: REJECT

âœ— Ingestion blocked (strict mode)

To override, use: cognition-cli genesis docs/VISION.md --force
```

---

## 10. Core Security vs Oâ‚‚ Security Overlay

### Side-by-Side Comparison

| Aspect              | Core Security                        | Oâ‚‚ Security Overlay                           |
| ------------------- | ------------------------------------ | --------------------------------------------- |
| **Purpose**         | Protect the lattice                  | Store app security knowledge                  |
| **Scope**           | Mission documents                    | Application code                              |
| **Threat Model**    | Mission poisoning                    | App vulnerabilities (XSS, CSRF, SQLi, etc.)   |
| **Storage**         | `.open_cognition/mission_integrity/` | `.open_cognition/overlays/O2_security/`       |
| **Components**      | MissionValidator, DriftDetector      | SecurityGuidelinesManager                     |
| **Knowledge Types** | N/A (validation only)                | threat_model, attack_vector, mitigation, etc. |
| **Queryable**       | No (internal system)                 | Yes (via lattice algebra)                     |
| **Configurable**    | Yes (security.json)                  | No (data only)                                |
| **Integration**     | Genesis command                      | Query commands (lattice, coherence)           |
| **User-Facing**     | Warnings during ingestion            | Results from queries                          |

### Analogy

**Core Security** = Firewall protecting the server

- Prevents malicious data from entering the system
- Monitors all incoming mission documents
- Blocks or warns about suspicious content

**Oâ‚‚ Security Overlay** = Security documentation on the server

- Contains knowledge about security best practices
- Provides guidance for developers
- Queryable for security recommendations

### Example Scenarios

#### Scenario 1: Mission Poisoning Attack

**Attack**: Developer submits PR changing "security first" to "pragmatic approach"

**Core Security Response**:

```bash
âš ï¸  Semantic drift detected: 0.22 distance
âš ï¸  Security weakening pattern: "pragmatic approach"
âš ï¸  Recommendation: REVIEW
```

**Oâ‚‚ Security Response**: N/A (not involved in mission validation)

#### Scenario 2: Query for Security Guidelines

**Query**: `cognition-cli lattice "O2 security guidelines for authentication"`

**Core Security Response**: N/A (doesn't store security knowledge)

**Oâ‚‚ Security Response**:

```
Found 5 security items:
1. [threat_model] Authentication bypass attacks
2. [mitigation] Use bcrypt for password hashing
3. [mitigation] Implement MFA for sensitive operations
4. [attack_vector] Session fixation attacks
5. [mitigation] Regenerate session IDs after login
```

#### Scenario 3: Cross-Layer Query (Oâ‚‚ âˆ§ Oâ‚)

**Query**: `cognition-cli lattice "O2 & O1 -> authentication"`

**Core Security Response**: N/A (doesn't participate in queries)

**Oâ‚‚ Security Response**:

```
Security items related to authentication code:
1. [mitigation] src/auth/login.ts
   - Use bcrypt for password hashing
   - Similarity: 0.82

2. [threat_model] src/auth/session.ts
   - Session fixation attacks
   - Similarity: 0.75
```

### When to Use Each

**Use Core Security**:

- Validating mission documents before ingestion
- Detecting mission drift over time
- Auditing mission integrity
- Configuring security policies

**Use Oâ‚‚ Security Overlay**:

- Querying security best practices
- Finding security-related code
- Cross-referencing threats and mitigations
- Generating security reports

**Use Both Together**:

- Core Security ensures mission integrity
- Oâ‚‚ Security provides application security knowledge
- Together: Complete cognitive security architecture

---

## Summary

Core Security protects **the lattice itself** from mission poisoning attacks through:

1. **MissionValidator**: Multi-layer validation (LLM, patterns, drift, structure)
2. **MissionIntegrityMonitor**: Immutable audit trail of mission versions
3. **SemanticDriftDetector**: Pattern-based detection of poisoning attempts
4. **SecurityConfig**: User control over validation modes and thresholds

**Key Properties**:

- Advisory by default (warn, don't block)
- Transparent (all detection logic documented)
- User control (easy to configure/disable)
- No telemetry (all analysis local)
- Augments humans (help reviewers, don't replace)

**Integration**: Genesis command validates mission documents before ingestion, records versions for forensic analysis, and provides evidence for human review.

**Distinction**: Core Security protects the cognitive system; Oâ‚‚ Security stores application security knowledge. Both are essential but serve different purposes.

---

**Next Chapter**: [Chapter 5: Oâ‚ Structure](../part-2-seven-layers/05-o1-structure.md) ğŸ“‹

**Previous Chapter**: [Chapter 4: Embeddings](04-embeddings.md) ğŸ“‹
